# --------------------------------------------------------------
# 1. Install required packages (run once)
# --------------------------------------------------------------
!pip install -q osmnx geopy matplotlib seaborn

# --------------------------------------------------------------
# 2. Imports
# --------------------------------------------------------------
import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
import seaborn as sns
import random
import statistics
from geopy.distance import geodesic

sns.set_style("whitegrid")
%matplotlib inline

# --------------------------------------------------------------
# 3. Load the three modal networks
# --------------------------------------------------------------
place_name = "Chicago, Illinois, USA"          # <-- change to any place you like
print(f"Downloading networks for: {place_name}")

# Load unprojected graphs first
G_drive_unproj = ox.graph_from_place(place_name, network_type='drive')
G_bike_unproj  = ox.graph_from_place(place_name, network_type='bike')
G_walk_unproj  = ox.graph_from_place(place_name, network_type='walk')


# Project to a metric CRS so that edge['length'] is in metres
G_drive = ox.project_graph(G_drive_unproj)
G_bike  = ox.project_graph(G_bike_unproj)
G_walk  = ox.project_graph(G_walk_unproj)

print(f"Nodes: drive={G_drive.number_of_nodes():,}, bike={G_bike.number_of_nodes():,}, walk={G_walk.number_of_nodes():,}")

# --------------------------------------------------------------
# 4. Find common nodes (only nodes present in *all* three graphs)
# --------------------------------------------------------------
common_nodes = set(G_drive.nodes) & set(G_bike.nodes) & set(G_walk.nodes)
print(f"Common nodes across all three networks: {len(common_nodes):,}")

# --------------------------------------------------------------
# 5. Sample OD pairs & compute circuity
# --------------------------------------------------------------
num_pairs = 5_000                     # 5 k is fast; increase to 100 k later if you wish
all_circuity = {"Driving": [], "Cycling": [], "Walking": []}

print(f"\nSampling {num_pairs:,} OD pairs …")
for i in range(num_pairs):
    if i % 1000 == 0 and i > 0:
        print(f"   … {i:,} pairs processed")

    o, d = random.sample(list(common_nodes), 2)

    # Lat-lon points (geopy works with (lat, lon)), use unprojected graphs
    o_pt = (G_drive_unproj.nodes[o]['y'], G_drive_unproj.nodes[o]['x'])
    d_pt = (G_drive_unproj.nodes[d]['y'], G_drive_unproj.nodes[d]['x'])

    haversine_m = geodesic(o_pt, d_pt).meters
    if haversine_m == 0:
        continue

    for mode, G in zip(all_circuity.keys(), [G_drive, G_bike, G_walk]):
        try:
            path_len = nx.shortest_path_length(G, o, d, weight='length')
            circ = path_len / haversine_m
            all_circuity[mode].append(circ)
        except nx.NetworkXNoPath:
            pass   # no path → ignore this OD pair for this mode

print("Sampling finished!")
for m, vals in all_circuity.items():
    print(f"   {m}: {len(vals):,} valid circuity values")

# --------------------------------------------------------------
# 6. Visualise the distributions
# --------------------------------------------------------------
fig, axes = plt.subplots(1, 3, figsize=(18, 5), sharey=True)

colors = {"Driving": "#1f77b4", "Cycling": "#ff7f0e", "Walking": "#2ca02c"}

for ax, (mode, data) in zip(axes, all_circuity.items()):
    if not data:
        ax.text(0.5, 0.5, "No data", ha='center', va='center', transform=ax.transAxes)
        ax.set_title(mode)
        continue

    # Histogram + KDE
    sns.histplot(data, bins=80, stat="density", ax=ax,
                 color=colors[mode], alpha=0.6, edgecolor="k", linewidth=0.5)
    sns.kdeplot(data, ax=ax, color=colors[mode], linewidth=2)

    # Stats overlay
    mean   = statistics.mean(data)
    median = statistics.median(data)
    std    = statistics.stdev(data) if len(data) > 1 else 0.0
    ax.axvline(mean,   color='red',   linestyle='--', label=f'mean = {mean:.3f}')
    ax.axvline(median, color='black', linestyle=':',  label=f'median = {median:.3f}')

    ax.set_title(f"{mode} Circuity (n={len(data):,})", fontsize=14)
    ax.set_xlabel("Circuity = network distance / straight-line distance")
    ax.legend(fontsize=9)

axes[0].set_ylabel("Density")
plt.suptitle(f"Circuity Distributions – {place_name}", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

# 1. Log-scale for heavy-tailed distributions
ax.set_xscale('log')

# 2. Box-plot side-by-side
plt.figure(figsize=(8,5))
sns.boxplot(data=[all_circuity[m] for m in all_circuity],
            palette=colors.values())
plt.xticks(range(3), all_circuity.keys())
plt.ylabel("Circuity")
plt.title("Circuity Box-Plots")
plt.show()
